# goit-algo-hw-09

# Опис домашнього завдання
У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет [50, 25, 10, 5, 2, 1]. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

#### Функція жадібного алгоритму find_coins_greedy.
Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.

#### Функція динамічного програмування find_min_coins. 
Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}

Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл readme.md домашнього завдання.

## Порівняння Жадібного Алгоритму та Динамічного Програмування

Алгоритми були випробувані для знаходження мінімальної кількості монет, необхідних для складання заданої суми, використовуючи монети номіналами 50, 25, 10, 5, 2 та 1.
Виконання включало базовий тест та перформанс тест на великих сумах.

### Результати Виконання

Базовий тест показав, що обидва алгоритми досягають однакового результату для суми `113`, ефективно визначаючи оптимальну кількість монет.

Перформанс тести на великих сумах показали, що існує велика різниця у часі виконання між жадібним алгоритмом та алгоритмом динамічного програмування.
- Жадібний алгоритм показав значно кращу продуктивність з мінімальним часом виконання
- Динамічне програмування вимагало значно більше часу, особливо на великих сумах.

#### Жадібний

| Тест | Набір Даних (сума) | Результат | Час Виконання (сек) | Big O Нотація |
|----------|---------------------|-----------|---------------------|---------------|
| 1 | 331            | {50: 6, 25: 1, 5: 1, 1: 1} | 0.000030 секунд | O(mn) |
| 2 | 1281         | {50: 25, 25: 1, 5: 1, 1: 1} | 0.000048 секунд | O(mn) |
| 3 | 83671        | {50: 1673, 10: 2, 1: 1} | 0.000589 секунд | O(mn) |
| 4 | 152044        | {50: 3040, 25: 1, 10: 1, 5: 1, 2: 2} | 0.000651 секунд | O(mn) |
| 5 | 4966714        | {50: 99334, 10: 1, 2: 2} | 0.032735 секунд | O(mn) |

#### Динамічний

| Тест | Набір Даних (сума) | Результат | Час Виконання (сек) | Big O Нотація |
|----------|---------------------|-----------|---------------------|---------------|
| 1 | 331              | {50: 6, 25: 1, 5: 1, 1: 1} | 0.001434 секунд | O(n) |
| 2 | 1281          | {50: 25, 25: 1, 5: 1, 1: 1} | 0.005595 секунд | O(n) |
| 3 | 83671         | {50: 1673, 10: 2, 1: 1} | 0.409811 секунд | O(n) |
| 4 | 152044       | {50: 3040, 25: 1, 10: 1, 5: 1, 2: 2} | 0.747330 секунд | O(n) |
| 5 | 4966714       | {50: 99334, 10: 1, 2: 2} | 24.277948 секунд | O(n) |

### Висновки

- **Big O Нотація**: Жадібний алгоритм має лінійну складність `O(n)`, де n — кількість монет. Динамічне програмування має складність `O(mn)`, де `m` — сума, а `n` — кількість номіналів монет. Це пояснює більш високу продуктивність жадібного алгоритму порівняно з динамічним програмуванням на великих сумах.
- **Оптимальність**: Обидва алгоритми видали однакові оптимальні результати для тестованих сум, хоча це не завжди може бути гарантовано для всіх систем монет у випадку жадібного алгоритму.
- **Час Виконання**: Жадібний алгоритм значно швидший за алгоритм динамічного програмування на великих сумах, що підтверджує його ефективність для задачі знаходження мінімальної кількості монет в даній системі монет.

У висновку, жадібний алгоритм є більш підходящим для швидкого знаходження мінімальної кількості монет у системах, де він забезпечує оптимальне рішення, тоді як динамічне програмування є більш універсальним, але менш ефективним за часом виконання.